/* tslint:disable */
/* eslint-disable */
/**
 * Theia Cloud API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.2.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface ActivityTracker
 */
export interface ActivityTracker {
    /**
     * 
     * @type {number}
     * @memberof ActivityTracker
     */
    'timeoutAfter'?: number;
    /**
     * 
     * @type {number}
     * @memberof ActivityTracker
     */
    'notifyAfter'?: number;
}
/**
 * 
 * @export
 * @interface AppDefinition
 */
export interface AppDefinition {
    /**
     * 
     * @type {string}
     * @memberof AppDefinition
     */
    'apiVersion'?: string;
    /**
     * 
     * @type {string}
     * @memberof AppDefinition
     */
    'kind'?: string;
    /**
     * 
     * @type {ObjectMeta}
     * @memberof AppDefinition
     */
    'metadata'?: ObjectMeta;
    /**
     * 
     * @type {AppDefinitionSpec}
     * @memberof AppDefinition
     */
    'spec'?: AppDefinitionSpec;
    /**
     * 
     * @type {AppDefinitionStatus}
     * @memberof AppDefinition
     */
    'status'?: AppDefinitionStatus;
    /**
     * 
     * @type {string}
     * @memberof AppDefinition
     */
    'singular'?: string;
    /**
     * 
     * @type {string}
     * @memberof AppDefinition
     */
    'crdName'?: string;
    /**
     * 
     * @type {string}
     * @memberof AppDefinition
     */
    'scope'?: string;
    /**
     * 
     * @type {string}
     * @memberof AppDefinition
     */
    'plural'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof AppDefinition
     */
    'served'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof AppDefinition
     */
    'storage'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof AppDefinition
     */
    'deprecated'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof AppDefinition
     */
    'deprecationWarning'?: string;
}
/**
 * A request to list available app definitions.
 * @export
 * @interface AppDefinitionListRequest
 */
export interface AppDefinitionListRequest {
    /**
     * The App Id of this Theia Cloud instance. Request without a matching Id will be denied.
     * @type {string}
     * @memberof AppDefinitionListRequest
     */
    'appId': string;
}
/**
 * 
 * @export
 * @interface AppDefinitionSpec
 */
export interface AppDefinitionSpec {
    /**
     * 
     * @type {string}
     * @memberof AppDefinitionSpec
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof AppDefinitionSpec
     */
    'image'?: string;
    /**
     * 
     * @type {string}
     * @memberof AppDefinitionSpec
     */
    'imagePullPolicy'?: string;
    /**
     * 
     * @type {string}
     * @memberof AppDefinitionSpec
     */
    'pullSecret'?: string;
    /**
     * 
     * @type {number}
     * @memberof AppDefinitionSpec
     */
    'uid'?: number;
    /**
     * 
     * @type {number}
     * @memberof AppDefinitionSpec
     */
    'port'?: number;
    /**
     * 
     * @type {string}
     * @memberof AppDefinitionSpec
     */
    'ingressname'?: string;
    /**
     * 
     * @type {number}
     * @memberof AppDefinitionSpec
     */
    'minInstances'?: number;
    /**
     * 
     * @type {number}
     * @memberof AppDefinitionSpec
     */
    'maxInstances'?: number;
    /**
     * 
     * @type {number}
     * @memberof AppDefinitionSpec
     */
    'timeout'?: number;
    /**
     * 
     * @type {string}
     * @memberof AppDefinitionSpec
     */
    'requestsMemory'?: string;
    /**
     * 
     * @type {string}
     * @memberof AppDefinitionSpec
     */
    'requestsCpu'?: string;
    /**
     * 
     * @type {string}
     * @memberof AppDefinitionSpec
     */
    'limitsMemory'?: string;
    /**
     * 
     * @type {string}
     * @memberof AppDefinitionSpec
     */
    'limitsCpu'?: string;
    /**
     * 
     * @type {number}
     * @memberof AppDefinitionSpec
     */
    'downlinkLimit'?: number;
    /**
     * 
     * @type {number}
     * @memberof AppDefinitionSpec
     */
    'uplinkLimit'?: number;
    /**
     * 
     * @type {string}
     * @memberof AppDefinitionSpec
     */
    'mountPath'?: string;
    /**
     * 
     * @type {Monitor}
     * @memberof AppDefinitionSpec
     */
    'monitor'?: Monitor;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof AppDefinitionSpec
     */
    'options'?: { [key: string]: string; };
    /**
     * 
     * @type {Array<string>}
     * @memberof AppDefinitionSpec
     */
    'ingressHostnamePrefixes'?: Array<string>;
}
/**
 * 
 * @export
 * @interface AppDefinitionStatus
 */
export interface AppDefinitionStatus {
    /**
     * 
     * @type {string}
     * @memberof AppDefinitionStatus
     */
    'operatorStatus'?: string;
    /**
     * 
     * @type {string}
     * @memberof AppDefinitionStatus
     */
    'operatorMessage'?: string;
}
/**
 * 
 * @export
 * @interface AppDefinitionUpdateRequest
 */
export interface AppDefinitionUpdateRequest {
    /**
     * The App Id of this Theia Cloud instance. Request without a matching Id will be denied.
     * @type {string}
     * @memberof AppDefinitionUpdateRequest
     */
    'appId': string;
    /**
     * The minimum number of instances to run.
     * @type {number}
     * @memberof AppDefinitionUpdateRequest
     */
    'minInstances'?: number;
    /**
     * The maximum number of instances to run.
     * @type {number}
     * @memberof AppDefinitionUpdateRequest
     */
    'maxInstances'?: number;
}
/**
 * An object to hold all the ways environment variables can be passed. Not to be used by itself.
 * @export
 * @interface EnvironmentVars
 */
export interface EnvironmentVars {
    /**
     * Map of environment variables to be passed to Deployment.  Ignored if Theia applications are started eagerly.  Empty by default.
     * @type {{ [key: string]: string; }}
     * @memberof EnvironmentVars
     */
    'fromMap'?: { [key: string]: string; };
    /**
     * List of ConfigMaps (by name) containing environment variables to be passed to Deployment as envFrom.configMapRef.  Ignored if Theia applications are started eagerly.  Empty by default.
     * @type {Array<string>}
     * @memberof EnvironmentVars
     */
    'fromConfigMaps'?: Array<string>;
    /**
     * List of Secrets (by name) containing environment variables to be passed to Deployment as envFrom.secretRef.  Ignored if Theia applications are started eagerly.  Empty by default.
     * @type {Array<string>}
     * @memberof EnvironmentVars
     */
    'fromSecrets'?: Array<string>;
}
/**
 * A request to launch a new session.
 * @export
 * @interface LaunchRequest
 */
export interface LaunchRequest {
    /**
     * The App Id of this Theia Cloud instance. Request without a matching Id will be denied.
     * @type {string}
     * @memberof LaunchRequest
     */
    'appId': string;
    /**
     * The user identification, usually the email address.
     * @type {string}
     * @memberof LaunchRequest
     */
    'user': string;
    /**
     * The app to launch. Needs to be set if a new or ephemeral session should be launched. For an existing workspace the last app definition will be used if none is given.
     * @type {string}
     * @memberof LaunchRequest
     */
    'appDefinition'?: string;
    /**
     * The name of the workspace to mount/create. Needs to be set if an existing workspace should be launched.
     * @type {string}
     * @memberof LaunchRequest
     */
    'workspaceName'?: string;
    /**
     * The label of the workspace to mount/create. If no label is given, a default label will be generated.
     * @type {string}
     * @memberof LaunchRequest
     */
    'label'?: string;
    /**
     * If true no workspace will be created for the session.
     * @type {boolean}
     * @memberof LaunchRequest
     */
    'ephemeral'?: boolean;
    /**
     * Number of minutes to wait for session launch. Default is 3 Minutes.
     * @type {number}
     * @memberof LaunchRequest
     */
    'timeout'?: number;
    /**
     * Environment variables
     * @type {EnvironmentVars}
     * @memberof LaunchRequest
     */
    'env'?: EnvironmentVars;
}
/**
 * 
 * @export
 * @interface ManagedFieldsEntry
 */
export interface ManagedFieldsEntry {
    /**
     * 
     * @type {string}
     * @memberof ManagedFieldsEntry
     */
    'apiVersion'?: string;
    /**
     * 
     * @type {string}
     * @memberof ManagedFieldsEntry
     */
    'fieldsType'?: string;
    /**
     * 
     * @type {object}
     * @memberof ManagedFieldsEntry
     */
    'fieldsV1'?: object;
    /**
     * 
     * @type {string}
     * @memberof ManagedFieldsEntry
     */
    'manager'?: string;
    /**
     * 
     * @type {string}
     * @memberof ManagedFieldsEntry
     */
    'operation'?: string;
    /**
     * 
     * @type {string}
     * @memberof ManagedFieldsEntry
     */
    'subresource'?: string;
    /**
     * 
     * @type {string}
     * @memberof ManagedFieldsEntry
     */
    'time'?: string;
}
/**
 * 
 * @export
 * @interface Monitor
 */
export interface Monitor {
    /**
     * 
     * @type {number}
     * @memberof Monitor
     */
    'port'?: number;
    /**
     * 
     * @type {ActivityTracker}
     * @memberof Monitor
     */
    'activityTracker'?: ActivityTracker;
}
/**
 * 
 * @export
 * @interface ObjectMeta
 */
export interface ObjectMeta {
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof ObjectMeta
     */
    'annotations'?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof ObjectMeta
     */
    'creationTimestamp'?: string;
    /**
     * 
     * @type {number}
     * @memberof ObjectMeta
     */
    'deletionGracePeriodSeconds'?: number;
    /**
     * 
     * @type {string}
     * @memberof ObjectMeta
     */
    'deletionTimestamp'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof ObjectMeta
     */
    'finalizers'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof ObjectMeta
     */
    'generateName'?: string;
    /**
     * 
     * @type {number}
     * @memberof ObjectMeta
     */
    'generation'?: number;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof ObjectMeta
     */
    'labels'?: { [key: string]: string; };
    /**
     * 
     * @type {Array<ManagedFieldsEntry>}
     * @memberof ObjectMeta
     */
    'managedFields'?: Array<ManagedFieldsEntry>;
    /**
     * 
     * @type {string}
     * @memberof ObjectMeta
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof ObjectMeta
     */
    'namespace'?: string;
    /**
     * 
     * @type {Array<OwnerReference>}
     * @memberof ObjectMeta
     */
    'ownerReferences'?: Array<OwnerReference>;
    /**
     * 
     * @type {string}
     * @memberof ObjectMeta
     */
    'resourceVersion'?: string;
    /**
     * 
     * @type {string}
     * @memberof ObjectMeta
     */
    'selfLink'?: string;
    /**
     * 
     * @type {string}
     * @memberof ObjectMeta
     */
    'uid'?: string;
}
/**
 * 
 * @export
 * @interface OwnerReference
 */
export interface OwnerReference {
    /**
     * 
     * @type {string}
     * @memberof OwnerReference
     */
    'apiVersion'?: string;
    /**
     * 
     * @type {string}
     * @memberof OwnerReference
     */
    'kind'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof OwnerReference
     */
    'blockOwnerDeletion'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof OwnerReference
     */
    'controller'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof OwnerReference
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof OwnerReference
     */
    'uid'?: string;
}
/**
 * Request to ping the availability of the service.
 * @export
 * @interface PingRequest
 */
export interface PingRequest {
    /**
     * The App Id of this Theia Cloud instance. Request without a matching Id will be denied.
     * @type {string}
     * @memberof PingRequest
     */
    'appId': string;
}
/**
 * A request to report activity for a running session.
 * @export
 * @interface SessionActivityRequest
 */
export interface SessionActivityRequest {
    /**
     * The App Id of this Theia Cloud instance. Request without a matching Id will be denied.
     * @type {string}
     * @memberof SessionActivityRequest
     */
    'appId': string;
    /**
     * The name of the session for which activity is reported.
     * @type {string}
     * @memberof SessionActivityRequest
     */
    'sessionName': string;
}
/**
 * A request to list the sessions of a user.
 * @export
 * @interface SessionListRequest
 */
export interface SessionListRequest {
    /**
     * The App Id of this Theia Cloud instance. Request without a matching Id will be denied.
     * @type {string}
     * @memberof SessionListRequest
     */
    'appId': string;
    /**
     * The user identification, usually the email address.
     * @type {string}
     * @memberof SessionListRequest
     */
    'user': string;
}
/**
 * Description of the performance of a session
 * @export
 * @interface SessionPerformance
 */
export interface SessionPerformance {
    /**
     * Used CPU amount of the workspace
     * @type {string}
     * @memberof SessionPerformance
     */
    'cpuAmount': string;
    /**
     * Used CPU format of the workspace
     * @type {string}
     * @memberof SessionPerformance
     */
    'cpuFormat': string;
    /**
     * Used memory amount of the workspace
     * @type {string}
     * @memberof SessionPerformance
     */
    'memoryAmount': string;
    /**
     * Used memory format of the workspace
     * @type {string}
     * @memberof SessionPerformance
     */
    'memoryFormat': string;
}
/**
 * A request to list the sessions of a user.
 * @export
 * @interface SessionPerformanceRequest
 */
export interface SessionPerformanceRequest {
    /**
     * The App Id of this Theia Cloud instance. Request without a matching Id will be denied.
     * @type {string}
     * @memberof SessionPerformanceRequest
     */
    'appId': string;
    /**
     * The name of the session
     * @type {string}
     * @memberof SessionPerformanceRequest
     */
    'sessionName': string;
}
/**
 * 
 * @export
 * @interface SessionSetConfigValueRequest
 */
export interface SessionSetConfigValueRequest {
    /**
     * The App Id of this Theia Cloud instance. Request without a matching Id will be denied.
     * @type {string}
     * @memberof SessionSetConfigValueRequest
     */
    'appId': string;
    /**
     * The configuration key
     * @type {string}
     * @memberof SessionSetConfigValueRequest
     */
    'key': string;
    /**
     * The configuration value
     * @type {string}
     * @memberof SessionSetConfigValueRequest
     */
    'value': string | null;
}
/**
 * 
 * @export
 * @interface SessionSpec
 */
export interface SessionSpec {
    /**
     * 
     * @type {string}
     * @memberof SessionSpec
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof SessionSpec
     */
    'appDefinition'?: string;
    /**
     * 
     * @type {string}
     * @memberof SessionSpec
     */
    'user'?: string;
    /**
     * 
     * @type {string}
     * @memberof SessionSpec
     */
    'workspace'?: string;
    /**
     * 
     * @type {string}
     * @memberof SessionSpec
     */
    'sessionSecret'?: string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof SessionSpec
     */
    'options'?: { [key: string]: string; };
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof SessionSpec
     */
    'envVars'?: { [key: string]: string; };
    /**
     * 
     * @type {Array<string>}
     * @memberof SessionSpec
     */
    'envVarsFromConfigMaps'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof SessionSpec
     */
    'envVarsFromSecrets'?: Array<string>;
}
/**
 * A request to start a session
 * @export
 * @interface SessionStartRequest
 */
export interface SessionStartRequest {
    /**
     * The App Id of this Theia Cloud instance. Request without a matching Id will be denied.
     * @type {string}
     * @memberof SessionStartRequest
     */
    'appId': string;
    /**
     * The user identification, usually the email address.
     * @type {string}
     * @memberof SessionStartRequest
     */
    'user': string;
    /**
     * The app to launch.
     * @type {string}
     * @memberof SessionStartRequest
     */
    'appDefinition': string;
    /**
     * The name of the workspace to mount/create.
     * @type {string}
     * @memberof SessionStartRequest
     */
    'workspaceName'?: string;
    /**
     * Number of minutes to wait for session launch. Default is 3 Minutes.
     * @type {number}
     * @memberof SessionStartRequest
     */
    'timeout'?: number;
    /**
     * Environment variables
     * @type {EnvironmentVars}
     * @memberof SessionStartRequest
     */
    'env'?: EnvironmentVars;
}
/**
 * A request to stop a session
 * @export
 * @interface SessionStopRequest
 */
export interface SessionStopRequest {
    /**
     * The App Id of this Theia Cloud instance. Request without a matching Id will be denied.
     * @type {string}
     * @memberof SessionStopRequest
     */
    'appId': string;
    /**
     * The user identification, usually the email address.
     * @type {string}
     * @memberof SessionStopRequest
     */
    'user': string;
    /**
     * The name of the session to stop.
     * @type {string}
     * @memberof SessionStopRequest
     */
    'sessionName': string;
}
/**
 * Description of a user workspace
 * @export
 * @interface UserWorkspace
 */
export interface UserWorkspace {
    /**
     * The name of the workspace
     * @type {string}
     * @memberof UserWorkspace
     */
    'name': string;
    /**
     * The label of the workspace
     * @type {string}
     * @memberof UserWorkspace
     */
    'label': string;
    /**
     * The app this workspace was used with.
     * @type {string}
     * @memberof UserWorkspace
     */
    'appDefinition'?: string;
    /**
     * The user identification, usually the email address.
     * @type {string}
     * @memberof UserWorkspace
     */
    'user': string;
    /**
     * Whether the workspace is in use at the moment.
     * @type {boolean}
     * @memberof UserWorkspace
     */
    'active': boolean;
}
/**
 * Request to create a new workspace.
 * @export
 * @interface WorkspaceCreationRequest
 */
export interface WorkspaceCreationRequest {
    /**
     * The App Id of this Theia Cloud instance. Request without a matching Id will be denied.
     * @type {string}
     * @memberof WorkspaceCreationRequest
     */
    'appId': string;
    /**
     * The user identification, usually the email address.
     * @type {string}
     * @memberof WorkspaceCreationRequest
     */
    'user': string;
    /**
     * The app this workspace will be used with.
     * @type {string}
     * @memberof WorkspaceCreationRequest
     */
    'appDefinition'?: string;
    /**
     * The label of the workspace
     * @type {string}
     * @memberof WorkspaceCreationRequest
     */
    'label'?: string;
}
/**
 * Request to delete a workspace
 * @export
 * @interface WorkspaceDeletionRequest
 */
export interface WorkspaceDeletionRequest {
    /**
     * The App Id of this Theia Cloud instance. Request without a matching Id will be denied.
     * @type {string}
     * @memberof WorkspaceDeletionRequest
     */
    'appId': string;
    /**
     * The user identification, usually the email address.
     * @type {string}
     * @memberof WorkspaceDeletionRequest
     */
    'user': string;
    /**
     * The name of the workspace to delete.
     * @type {string}
     * @memberof WorkspaceDeletionRequest
     */
    'workspaceName': string;
}
/**
 * Request to list workspaces of a user.
 * @export
 * @interface WorkspaceListRequest
 */
export interface WorkspaceListRequest {
    /**
     * The App Id of this Theia Cloud instance. Request without a matching Id will be denied.
     * @type {string}
     * @memberof WorkspaceListRequest
     */
    'appId': string;
    /**
     * The user identification, usually the email address.
     * @type {string}
     * @memberof WorkspaceListRequest
     */
    'user': string;
}

/**
 * AppDefinitionAdminResourceApi - axios parameter creator
 * @export
 */
export const AppDefinitionAdminResourceApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Updates an app definition\'s properties. Allowed properties to update are defined by AppDefinitionUpdateRequest.
         * @summary Updates an app definition
         * @param {string} appDefinitionName The K8S resource name of the app definition to update.
         * @param {AppDefinitionUpdateRequest} appDefinitionUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serviceAdminAppdefinitionAppDefinitionNamePatch: async (appDefinitionName: string, appDefinitionUpdateRequest: AppDefinitionUpdateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'appDefinitionName' is not null or undefined
            assertParamExists('serviceAdminAppdefinitionAppDefinitionNamePatch', 'appDefinitionName', appDefinitionName)
            // verify required parameter 'appDefinitionUpdateRequest' is not null or undefined
            assertParamExists('serviceAdminAppdefinitionAppDefinitionNamePatch', 'appDefinitionUpdateRequest', appDefinitionUpdateRequest)
            const localVarPath = `/service/admin/appdefinition/{appDefinitionName}`
                .replace(`{${"appDefinitionName"}}`, encodeURIComponent(String(appDefinitionName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(appDefinitionUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AppDefinitionAdminResourceApi - functional programming interface
 * @export
 */
export const AppDefinitionAdminResourceApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AppDefinitionAdminResourceApiAxiosParamCreator(configuration)
    return {
        /**
         * Updates an app definition\'s properties. Allowed properties to update are defined by AppDefinitionUpdateRequest.
         * @summary Updates an app definition
         * @param {string} appDefinitionName The K8S resource name of the app definition to update.
         * @param {AppDefinitionUpdateRequest} appDefinitionUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async serviceAdminAppdefinitionAppDefinitionNamePatch(appDefinitionName: string, appDefinitionUpdateRequest: AppDefinitionUpdateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AppDefinition>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.serviceAdminAppdefinitionAppDefinitionNamePatch(appDefinitionName, appDefinitionUpdateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AppDefinitionAdminResourceApi.serviceAdminAppdefinitionAppDefinitionNamePatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AppDefinitionAdminResourceApi - factory interface
 * @export
 */
export const AppDefinitionAdminResourceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AppDefinitionAdminResourceApiFp(configuration)
    return {
        /**
         * Updates an app definition\'s properties. Allowed properties to update are defined by AppDefinitionUpdateRequest.
         * @summary Updates an app definition
         * @param {string} appDefinitionName The K8S resource name of the app definition to update.
         * @param {AppDefinitionUpdateRequest} appDefinitionUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serviceAdminAppdefinitionAppDefinitionNamePatch(appDefinitionName: string, appDefinitionUpdateRequest: AppDefinitionUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<AppDefinition> {
            return localVarFp.serviceAdminAppdefinitionAppDefinitionNamePatch(appDefinitionName, appDefinitionUpdateRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AppDefinitionAdminResourceApi - object-oriented interface
 * @export
 * @class AppDefinitionAdminResourceApi
 * @extends {BaseAPI}
 */
export class AppDefinitionAdminResourceApi extends BaseAPI {
    /**
     * Updates an app definition\'s properties. Allowed properties to update are defined by AppDefinitionUpdateRequest.
     * @summary Updates an app definition
     * @param {string} appDefinitionName The K8S resource name of the app definition to update.
     * @param {AppDefinitionUpdateRequest} appDefinitionUpdateRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AppDefinitionAdminResourceApi
     */
    public serviceAdminAppdefinitionAppDefinitionNamePatch(appDefinitionName: string, appDefinitionUpdateRequest: AppDefinitionUpdateRequest, options?: RawAxiosRequestConfig) {
        return AppDefinitionAdminResourceApiFp(this.configuration).serviceAdminAppdefinitionAppDefinitionNamePatch(appDefinitionName, appDefinitionUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * AppDefinitionResourceApi - axios parameter creator
 * @export
 */
export const AppDefinitionResourceApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * List available app definitions.
         * @summary List app definitions
         * @param {string} appId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serviceAppdefinitionAppIdGet: async (appId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('serviceAppdefinitionAppIdGet', 'appId', appId)
            const localVarPath = `/service/appdefinition/{appId}`
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication SecurityScheme required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "SecurityScheme", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AppDefinitionResourceApi - functional programming interface
 * @export
 */
export const AppDefinitionResourceApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AppDefinitionResourceApiAxiosParamCreator(configuration)
    return {
        /**
         * List available app definitions.
         * @summary List app definitions
         * @param {string} appId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async serviceAppdefinitionAppIdGet(appId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AppDefinitionSpec>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.serviceAppdefinitionAppIdGet(appId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AppDefinitionResourceApi.serviceAppdefinitionAppIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AppDefinitionResourceApi - factory interface
 * @export
 */
export const AppDefinitionResourceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AppDefinitionResourceApiFp(configuration)
    return {
        /**
         * List available app definitions.
         * @summary List app definitions
         * @param {string} appId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serviceAppdefinitionAppIdGet(appId: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<AppDefinitionSpec>> {
            return localVarFp.serviceAppdefinitionAppIdGet(appId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AppDefinitionResourceApi - object-oriented interface
 * @export
 * @class AppDefinitionResourceApi
 * @extends {BaseAPI}
 */
export class AppDefinitionResourceApi extends BaseAPI {
    /**
     * List available app definitions.
     * @summary List app definitions
     * @param {string} appId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AppDefinitionResourceApi
     */
    public serviceAppdefinitionAppIdGet(appId: string, options?: RawAxiosRequestConfig) {
        return AppDefinitionResourceApiFp(this.configuration).serviceAppdefinitionAppIdGet(appId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * RootAdminResourceApi - axios parameter creator
 * @export
 */
export const RootAdminResourceApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Replies with success if the service is available and the user an admin.
         * @summary Admin Ping
         * @param {string} appId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serviceAdminAppIdGet: async (appId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('serviceAdminAppIdGet', 'appId', appId)
            const localVarPath = `/service/admin/{appId}`
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RootAdminResourceApi - functional programming interface
 * @export
 */
export const RootAdminResourceApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RootAdminResourceApiAxiosParamCreator(configuration)
    return {
        /**
         * Replies with success if the service is available and the user an admin.
         * @summary Admin Ping
         * @param {string} appId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async serviceAdminAppIdGet(appId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.serviceAdminAppIdGet(appId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RootAdminResourceApi.serviceAdminAppIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * RootAdminResourceApi - factory interface
 * @export
 */
export const RootAdminResourceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RootAdminResourceApiFp(configuration)
    return {
        /**
         * Replies with success if the service is available and the user an admin.
         * @summary Admin Ping
         * @param {string} appId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serviceAdminAppIdGet(appId: string, options?: RawAxiosRequestConfig): AxiosPromise<boolean> {
            return localVarFp.serviceAdminAppIdGet(appId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RootAdminResourceApi - object-oriented interface
 * @export
 * @class RootAdminResourceApi
 * @extends {BaseAPI}
 */
export class RootAdminResourceApi extends BaseAPI {
    /**
     * Replies with success if the service is available and the user an admin.
     * @summary Admin Ping
     * @param {string} appId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RootAdminResourceApi
     */
    public serviceAdminAppIdGet(appId: string, options?: RawAxiosRequestConfig) {
        return RootAdminResourceApiFp(this.configuration).serviceAdminAppIdGet(appId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * RootResourceApi - axios parameter creator
 * @export
 */
export const RootResourceApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Replies if the service is available.
         * @summary Ping
         * @param {string} appId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serviceAppIdGet: async (appId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('serviceAppIdGet', 'appId', appId)
            const localVarPath = `/service/{appId}`
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication SecurityScheme required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "SecurityScheme", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Launches a session and creates a workspace if required. Responds with the URL of the launched session.
         * @summary Launch Session
         * @param {LaunchRequest} launchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        servicePost: async (launchRequest: LaunchRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'launchRequest' is not null or undefined
            assertParamExists('servicePost', 'launchRequest', launchRequest)
            const localVarPath = `/service`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication SecurityScheme required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "SecurityScheme", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(launchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RootResourceApi - functional programming interface
 * @export
 */
export const RootResourceApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RootResourceApiAxiosParamCreator(configuration)
    return {
        /**
         * Replies if the service is available.
         * @summary Ping
         * @param {string} appId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async serviceAppIdGet(appId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.serviceAppIdGet(appId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RootResourceApi.serviceAppIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Launches a session and creates a workspace if required. Responds with the URL of the launched session.
         * @summary Launch Session
         * @param {LaunchRequest} launchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async servicePost(launchRequest: LaunchRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.servicePost(launchRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RootResourceApi.servicePost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * RootResourceApi - factory interface
 * @export
 */
export const RootResourceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RootResourceApiFp(configuration)
    return {
        /**
         * Replies if the service is available.
         * @summary Ping
         * @param {string} appId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serviceAppIdGet(appId: string, options?: RawAxiosRequestConfig): AxiosPromise<boolean> {
            return localVarFp.serviceAppIdGet(appId, options).then((request) => request(axios, basePath));
        },
        /**
         * Launches a session and creates a workspace if required. Responds with the URL of the launched session.
         * @summary Launch Session
         * @param {LaunchRequest} launchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        servicePost(launchRequest: LaunchRequest, options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.servicePost(launchRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RootResourceApi - object-oriented interface
 * @export
 * @class RootResourceApi
 * @extends {BaseAPI}
 */
export class RootResourceApi extends BaseAPI {
    /**
     * Replies if the service is available.
     * @summary Ping
     * @param {string} appId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RootResourceApi
     */
    public serviceAppIdGet(appId: string, options?: RawAxiosRequestConfig) {
        return RootResourceApiFp(this.configuration).serviceAppIdGet(appId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Launches a session and creates a workspace if required. Responds with the URL of the launched session.
     * @summary Launch Session
     * @param {LaunchRequest} launchRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RootResourceApi
     */
    public servicePost(launchRequest: LaunchRequest, options?: RawAxiosRequestConfig) {
        return RootResourceApiFp(this.configuration).servicePost(launchRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SessionResourceApi - axios parameter creator
 * @export
 */
export const SessionResourceApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * List sessions of a user.
         * @summary List sessions
         * @param {string} appId 
         * @param {string} user 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serviceSessionAppIdUserGet: async (appId: string, user: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('serviceSessionAppIdUserGet', 'appId', appId)
            // verify required parameter 'user' is not null or undefined
            assertParamExists('serviceSessionAppIdUserGet', 'user', user)
            const localVarPath = `/service/session/{appId}/{user}`
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"user"}}`, encodeURIComponent(String(user)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication SecurityScheme required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "SecurityScheme", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Stops a session.
         * @summary Stop session
         * @param {SessionStopRequest} sessionStopRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serviceSessionDelete: async (sessionStopRequest: SessionStopRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sessionStopRequest' is not null or undefined
            assertParamExists('serviceSessionDelete', 'sessionStopRequest', sessionStopRequest)
            const localVarPath = `/service/session`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication SecurityScheme required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "SecurityScheme", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(sessionStopRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the last activity timestamp for a session to monitor activity.
         * @summary Report session activity
         * @param {SessionActivityRequest} sessionActivityRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serviceSessionPatch: async (sessionActivityRequest: SessionActivityRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sessionActivityRequest' is not null or undefined
            assertParamExists('serviceSessionPatch', 'sessionActivityRequest', sessionActivityRequest)
            const localVarPath = `/service/session`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication SecurityScheme required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "SecurityScheme", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(sessionActivityRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the current CPU and memory usage of the session\'s pod.
         * @summary Get performance metrics
         * @param {string} appId 
         * @param {string} sessionName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serviceSessionPerformanceAppIdSessionNameGet: async (appId: string, sessionName: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('serviceSessionPerformanceAppIdSessionNameGet', 'appId', appId)
            // verify required parameter 'sessionName' is not null or undefined
            assertParamExists('serviceSessionPerformanceAppIdSessionNameGet', 'sessionName', sessionName)
            const localVarPath = `/service/session/performance/{appId}/{sessionName}`
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"sessionName"}}`, encodeURIComponent(String(sessionName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication SecurityScheme required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "SecurityScheme", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Starts a new session for an existing workspace and responds with the URL of the started session.
         * @summary Start a new session
         * @param {SessionStartRequest} sessionStartRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serviceSessionPost: async (sessionStartRequest: SessionStartRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sessionStartRequest' is not null or undefined
            assertParamExists('serviceSessionPost', 'sessionStartRequest', sessionStartRequest)
            const localVarPath = `/service/session`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication SecurityScheme required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "SecurityScheme", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(sessionStartRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Sets a config value in the config store if it is available. This requires the @eclipse-theiacloud/config-store Theia extension to be present in the application.
         * @summary Set config value
         * @param {string} session The name of the session
         * @param {SessionSetConfigValueRequest} sessionSetConfigValueRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serviceSessionSessionConfigPost: async (session: string, sessionSetConfigValueRequest: SessionSetConfigValueRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'session' is not null or undefined
            assertParamExists('serviceSessionSessionConfigPost', 'session', session)
            // verify required parameter 'sessionSetConfigValueRequest' is not null or undefined
            assertParamExists('serviceSessionSessionConfigPost', 'sessionSetConfigValueRequest', sessionSetConfigValueRequest)
            const localVarPath = `/service/session/{session}/config`
                .replace(`{${"session"}}`, encodeURIComponent(String(session)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication SecurityScheme required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "SecurityScheme", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(sessionSetConfigValueRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SessionResourceApi - functional programming interface
 * @export
 */
export const SessionResourceApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SessionResourceApiAxiosParamCreator(configuration)
    return {
        /**
         * List sessions of a user.
         * @summary List sessions
         * @param {string} appId 
         * @param {string} user 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async serviceSessionAppIdUserGet(appId: string, user: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SessionSpec>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.serviceSessionAppIdUserGet(appId, user, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SessionResourceApi.serviceSessionAppIdUserGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Stops a session.
         * @summary Stop session
         * @param {SessionStopRequest} sessionStopRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async serviceSessionDelete(sessionStopRequest: SessionStopRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.serviceSessionDelete(sessionStopRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SessionResourceApi.serviceSessionDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates the last activity timestamp for a session to monitor activity.
         * @summary Report session activity
         * @param {SessionActivityRequest} sessionActivityRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async serviceSessionPatch(sessionActivityRequest: SessionActivityRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.serviceSessionPatch(sessionActivityRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SessionResourceApi.serviceSessionPatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns the current CPU and memory usage of the session\'s pod.
         * @summary Get performance metrics
         * @param {string} appId 
         * @param {string} sessionName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async serviceSessionPerformanceAppIdSessionNameGet(appId: string, sessionName: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SessionPerformance>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.serviceSessionPerformanceAppIdSessionNameGet(appId, sessionName, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SessionResourceApi.serviceSessionPerformanceAppIdSessionNameGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Starts a new session for an existing workspace and responds with the URL of the started session.
         * @summary Start a new session
         * @param {SessionStartRequest} sessionStartRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async serviceSessionPost(sessionStartRequest: SessionStartRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.serviceSessionPost(sessionStartRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SessionResourceApi.serviceSessionPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Sets a config value in the config store if it is available. This requires the @eclipse-theiacloud/config-store Theia extension to be present in the application.
         * @summary Set config value
         * @param {string} session The name of the session
         * @param {SessionSetConfigValueRequest} sessionSetConfigValueRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async serviceSessionSessionConfigPost(session: string, sessionSetConfigValueRequest: SessionSetConfigValueRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.serviceSessionSessionConfigPost(session, sessionSetConfigValueRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SessionResourceApi.serviceSessionSessionConfigPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SessionResourceApi - factory interface
 * @export
 */
export const SessionResourceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SessionResourceApiFp(configuration)
    return {
        /**
         * List sessions of a user.
         * @summary List sessions
         * @param {string} appId 
         * @param {string} user 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serviceSessionAppIdUserGet(appId: string, user: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<SessionSpec>> {
            return localVarFp.serviceSessionAppIdUserGet(appId, user, options).then((request) => request(axios, basePath));
        },
        /**
         * Stops a session.
         * @summary Stop session
         * @param {SessionStopRequest} sessionStopRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serviceSessionDelete(sessionStopRequest: SessionStopRequest, options?: RawAxiosRequestConfig): AxiosPromise<boolean> {
            return localVarFp.serviceSessionDelete(sessionStopRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the last activity timestamp for a session to monitor activity.
         * @summary Report session activity
         * @param {SessionActivityRequest} sessionActivityRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serviceSessionPatch(sessionActivityRequest: SessionActivityRequest, options?: RawAxiosRequestConfig): AxiosPromise<boolean> {
            return localVarFp.serviceSessionPatch(sessionActivityRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the current CPU and memory usage of the session\'s pod.
         * @summary Get performance metrics
         * @param {string} appId 
         * @param {string} sessionName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serviceSessionPerformanceAppIdSessionNameGet(appId: string, sessionName: string, options?: RawAxiosRequestConfig): AxiosPromise<SessionPerformance> {
            return localVarFp.serviceSessionPerformanceAppIdSessionNameGet(appId, sessionName, options).then((request) => request(axios, basePath));
        },
        /**
         * Starts a new session for an existing workspace and responds with the URL of the started session.
         * @summary Start a new session
         * @param {SessionStartRequest} sessionStartRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serviceSessionPost(sessionStartRequest: SessionStartRequest, options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.serviceSessionPost(sessionStartRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Sets a config value in the config store if it is available. This requires the @eclipse-theiacloud/config-store Theia extension to be present in the application.
         * @summary Set config value
         * @param {string} session The name of the session
         * @param {SessionSetConfigValueRequest} sessionSetConfigValueRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serviceSessionSessionConfigPost(session: string, sessionSetConfigValueRequest: SessionSetConfigValueRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.serviceSessionSessionConfigPost(session, sessionSetConfigValueRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SessionResourceApi - object-oriented interface
 * @export
 * @class SessionResourceApi
 * @extends {BaseAPI}
 */
export class SessionResourceApi extends BaseAPI {
    /**
     * List sessions of a user.
     * @summary List sessions
     * @param {string} appId 
     * @param {string} user 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionResourceApi
     */
    public serviceSessionAppIdUserGet(appId: string, user: string, options?: RawAxiosRequestConfig) {
        return SessionResourceApiFp(this.configuration).serviceSessionAppIdUserGet(appId, user, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Stops a session.
     * @summary Stop session
     * @param {SessionStopRequest} sessionStopRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionResourceApi
     */
    public serviceSessionDelete(sessionStopRequest: SessionStopRequest, options?: RawAxiosRequestConfig) {
        return SessionResourceApiFp(this.configuration).serviceSessionDelete(sessionStopRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates the last activity timestamp for a session to monitor activity.
     * @summary Report session activity
     * @param {SessionActivityRequest} sessionActivityRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionResourceApi
     */
    public serviceSessionPatch(sessionActivityRequest: SessionActivityRequest, options?: RawAxiosRequestConfig) {
        return SessionResourceApiFp(this.configuration).serviceSessionPatch(sessionActivityRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the current CPU and memory usage of the session\'s pod.
     * @summary Get performance metrics
     * @param {string} appId 
     * @param {string} sessionName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionResourceApi
     */
    public serviceSessionPerformanceAppIdSessionNameGet(appId: string, sessionName: string, options?: RawAxiosRequestConfig) {
        return SessionResourceApiFp(this.configuration).serviceSessionPerformanceAppIdSessionNameGet(appId, sessionName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Starts a new session for an existing workspace and responds with the URL of the started session.
     * @summary Start a new session
     * @param {SessionStartRequest} sessionStartRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionResourceApi
     */
    public serviceSessionPost(sessionStartRequest: SessionStartRequest, options?: RawAxiosRequestConfig) {
        return SessionResourceApiFp(this.configuration).serviceSessionPost(sessionStartRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Sets a config value in the config store if it is available. This requires the @eclipse-theiacloud/config-store Theia extension to be present in the application.
     * @summary Set config value
     * @param {string} session The name of the session
     * @param {SessionSetConfigValueRequest} sessionSetConfigValueRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionResourceApi
     */
    public serviceSessionSessionConfigPost(session: string, sessionSetConfigValueRequest: SessionSetConfigValueRequest, options?: RawAxiosRequestConfig) {
        return SessionResourceApiFp(this.configuration).serviceSessionSessionConfigPost(session, sessionSetConfigValueRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * WorkspaceResourceApi - axios parameter creator
 * @export
 */
export const WorkspaceResourceApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Lists the workspaces of a user.
         * @summary List workspaces
         * @param {string} appId 
         * @param {string} user 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serviceWorkspaceAppIdUserGet: async (appId: string, user: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('serviceWorkspaceAppIdUserGet', 'appId', appId)
            // verify required parameter 'user' is not null or undefined
            assertParamExists('serviceWorkspaceAppIdUserGet', 'user', user)
            const localVarPath = `/service/workspace/{appId}/{user}`
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"user"}}`, encodeURIComponent(String(user)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication SecurityScheme required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "SecurityScheme", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a workspace.
         * @summary Delete workspace
         * @param {WorkspaceDeletionRequest} workspaceDeletionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serviceWorkspaceDelete: async (workspaceDeletionRequest: WorkspaceDeletionRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceDeletionRequest' is not null or undefined
            assertParamExists('serviceWorkspaceDelete', 'workspaceDeletionRequest', workspaceDeletionRequest)
            const localVarPath = `/service/workspace`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication SecurityScheme required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "SecurityScheme", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(workspaceDeletionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a new workspace for a user.
         * @summary Create workspace
         * @param {WorkspaceCreationRequest} workspaceCreationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serviceWorkspacePost: async (workspaceCreationRequest: WorkspaceCreationRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceCreationRequest' is not null or undefined
            assertParamExists('serviceWorkspacePost', 'workspaceCreationRequest', workspaceCreationRequest)
            const localVarPath = `/service/workspace`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication SecurityScheme required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "SecurityScheme", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(workspaceCreationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WorkspaceResourceApi - functional programming interface
 * @export
 */
export const WorkspaceResourceApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = WorkspaceResourceApiAxiosParamCreator(configuration)
    return {
        /**
         * Lists the workspaces of a user.
         * @summary List workspaces
         * @param {string} appId 
         * @param {string} user 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async serviceWorkspaceAppIdUserGet(appId: string, user: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserWorkspace>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.serviceWorkspaceAppIdUserGet(appId, user, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkspaceResourceApi.serviceWorkspaceAppIdUserGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Deletes a workspace.
         * @summary Delete workspace
         * @param {WorkspaceDeletionRequest} workspaceDeletionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async serviceWorkspaceDelete(workspaceDeletionRequest: WorkspaceDeletionRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.serviceWorkspaceDelete(workspaceDeletionRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkspaceResourceApi.serviceWorkspaceDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Creates a new workspace for a user.
         * @summary Create workspace
         * @param {WorkspaceCreationRequest} workspaceCreationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async serviceWorkspacePost(workspaceCreationRequest: WorkspaceCreationRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserWorkspace>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.serviceWorkspacePost(workspaceCreationRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkspaceResourceApi.serviceWorkspacePost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * WorkspaceResourceApi - factory interface
 * @export
 */
export const WorkspaceResourceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = WorkspaceResourceApiFp(configuration)
    return {
        /**
         * Lists the workspaces of a user.
         * @summary List workspaces
         * @param {string} appId 
         * @param {string} user 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serviceWorkspaceAppIdUserGet(appId: string, user: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<UserWorkspace>> {
            return localVarFp.serviceWorkspaceAppIdUserGet(appId, user, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes a workspace.
         * @summary Delete workspace
         * @param {WorkspaceDeletionRequest} workspaceDeletionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serviceWorkspaceDelete(workspaceDeletionRequest: WorkspaceDeletionRequest, options?: RawAxiosRequestConfig): AxiosPromise<boolean> {
            return localVarFp.serviceWorkspaceDelete(workspaceDeletionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new workspace for a user.
         * @summary Create workspace
         * @param {WorkspaceCreationRequest} workspaceCreationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serviceWorkspacePost(workspaceCreationRequest: WorkspaceCreationRequest, options?: RawAxiosRequestConfig): AxiosPromise<UserWorkspace> {
            return localVarFp.serviceWorkspacePost(workspaceCreationRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * WorkspaceResourceApi - object-oriented interface
 * @export
 * @class WorkspaceResourceApi
 * @extends {BaseAPI}
 */
export class WorkspaceResourceApi extends BaseAPI {
    /**
     * Lists the workspaces of a user.
     * @summary List workspaces
     * @param {string} appId 
     * @param {string} user 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspaceResourceApi
     */
    public serviceWorkspaceAppIdUserGet(appId: string, user: string, options?: RawAxiosRequestConfig) {
        return WorkspaceResourceApiFp(this.configuration).serviceWorkspaceAppIdUserGet(appId, user, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes a workspace.
     * @summary Delete workspace
     * @param {WorkspaceDeletionRequest} workspaceDeletionRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspaceResourceApi
     */
    public serviceWorkspaceDelete(workspaceDeletionRequest: WorkspaceDeletionRequest, options?: RawAxiosRequestConfig) {
        return WorkspaceResourceApiFp(this.configuration).serviceWorkspaceDelete(workspaceDeletionRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a new workspace for a user.
     * @summary Create workspace
     * @param {WorkspaceCreationRequest} workspaceCreationRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspaceResourceApi
     */
    public serviceWorkspacePost(workspaceCreationRequest: WorkspaceCreationRequest, options?: RawAxiosRequestConfig) {
        return WorkspaceResourceApiFp(this.configuration).serviceWorkspacePost(workspaceCreationRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



